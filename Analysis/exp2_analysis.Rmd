---
title: "Exp 2 analysis"
author: "Kenny Smith"
date: "19/12/2023"
output: html_document
---

This builds from the analysis for Exp 1. The main difference in Exp 2 is that the second extension block (Coloured Shapes, Objects, Emotions) was between-subjects, so each pair does only one of those blocks.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2) #for plots
library(lme4) #for stats
set.seed(21032023) #setting seed (to a date while working on the code) to allow replication of distance zscore plots.

my.colours <- c("#006DE9","#EA7D00")
```

# Data loading etc

Read in anonymised data - clean-up has been done during the anonymisation process, so only participants with valid data who did not take notes etc is included here.
```{r}
data <- read.csv("data/exp2_data_anonymised.csv")
```

## Number of pairs per condition

Quick look at number of remaining pairs per condition.

```{r}
plyr::ddply(data,~block3_condition+condition,plyr::summarise,Current_N=length(unique(pair_id)))
```

# Plots and stats

## Plots and stats of success vs block

Score is recorded only on matcher trials so can discard the director trials for the score analyses.

```{r}
matcher_data <- subset(data,exp_trial_type=='matcher')
```

Score=1 on trials where the matcher succesfully selected the target, score=0 otherwise.

Plotting by-pair average score (i.e. proportion of score=1 trials) per block. I want a dotplot so we can individual pairs. 

```{r, echo=FALSE}
pair_means_per_block <- aggregate(data=matcher_data,score~block_n+block3_condition+condition+pair_id,FUN=mean)
#need block_n as a factor for the dotplot
pair_means_per_block$block_n_as_factor <- factor(pair_means_per_block$block_n)

pair_means_per_block$named_condition <- plyr::revalue(pair_means_per_block$condition,
                                              c("fixed_associations"="Fixed Associations",
                                                "random_associations"="Random Associations"))

pair_means_per_block$named_block_n <- plyr::revalue(pair_means_per_block$block_n_as_factor,
                                              c("0"="White Shapes",
                                                "1"="Shapes",
                                                "2"="Coloured\nSplats",
                                                "3"="Second\nExtension"))

pair_means_per_block$named_block3_condition <- plyr::revalue(pair_means_per_block$block3_condition,
                                              c("coloured_shapes"="Coloured Shapes",
                                                "objects"="Objects",
                                                "emotions"="Emotions"))

ggplot(data=pair_means_per_block,aes(x=named_block_n, y=score)) +
  facet_grid(named_block3_condition~named_condition) +
  stat_summary(geom='point', fun='mean', colour='black',fill='black',size=2, shape=23) +
  stat_summary(geom='errorbar', fun.data='mean_cl_boot',fun.min="min", fun.max="max",width=0.2) +
  geom_dotplot(aes(x=named_block_n, y=score,fill=condition),binaxis='y',stackdir="center", binwidth = .025, binpositions='all', dotsize=0.5, alpha=0.5) +
  scale_fill_manual(values=my.colours) +
  theme_bw() +
  theme(legend.position = "none") +
  theme(axis.title.x = element_blank()) +
  ylab("Proportion of succesful trials")
```

Same plot just showing block 2 onwards, since all the points clustered at 1 in block 1 makes it a bit hard to see what's happening in block 2!

```{r, echo=FALSE}
ggplot(data=subset(pair_means_per_block,block_n>=2),aes(x=named_block_n, y=score)) +
  facet_grid(named_block3_condition~named_condition) +
  stat_summary(geom='point', fun='mean', colour='black',fill='black',size=2, shape=23) +
  stat_summary(geom='errorbar', fun.data='mean_cl_boot',fun.min="min", fun.max="max",width=0.2) +
  geom_dotplot(aes(x=named_block_n, y=score,fill=condition),binaxis='y',stackdir="center", binwidth = .025, binpositions='all', dotsize=0.5, alpha=0.5) +
  scale_fill_manual(values=my.colours) +
  theme_bw() +
  theme(legend.position = "none") +
  theme(axis.title.x = element_blank()) +
  ylab("Proportion of succesful trials") 
```

Plotting in the same style used for Experiment 1 (but now unlike Exp 1 the extension to shapes/objects/emotions is between-subjects).

```{r, echo=FALSE}

pair_means_per_block_replot <- pair_means_per_block
pair_means_per_block_replot$temp <- paste(pair_means_per_block_replot$block_n,pair_means_per_block_replot$named_block3_condition)
pair_means_per_block_replot$temp2 <- plyr::revalue(factor(pair_means_per_block_replot$temp),
                                              c("0 Objects"="White Shapes",
                                                "1 Objects"="Shapes",
                                                "2 Objects" = "Coloured\nSplats",
                                                "3 Objects" = "Objects",
                                                "0 Emotions"="White Shapes",
                                                "1 Emotions"="Shapes",
                                                "2 Emotions" = "Coloured\nSplats",
                                                "3 Emotions" = "Emotions",
                                                "0 Coloured Shapes"="White Shapes",
                                                "1 Coloured Shapes"="Shapes",
                                                "2 Coloured Shapes" = "Coloured\nSplats",
                                                "3 Coloured Shapes" = "Coloured\nShapes"))
                                                
                                                
pair_means_per_block_replot$temp2 <- factor(pair_means_per_block_replot$temp2,levels=c("Coloured\nSplats","Coloured\nShapes","Objects","Emotions"))
```


```{r, echo=FALSE}
ggplot(data=subset(pair_means_per_block_replot,block_n>=2),aes(x=temp2, y=score)) +
  facet_grid(~named_condition) +
  stat_summary(geom='point', fun='mean', colour='black',fill='black',size=2, shape=23) +
  stat_summary(geom='errorbar', fun.data='mean_cl_boot',fun.min="min", fun.max="max",width=0.2) +
  geom_dotplot(aes(x=temp2, y=score,fill=condition),binaxis='y',stackdir="center", binwidth = .025, binpositions='all', dotsize=0.5, alpha=0.5) +
  scale_fill_manual(values=my.colours) +
  theme_bw() +
  theme(legend.position = "none") +
  theme(axis.title.x = element_blank()) +
  ylab("Proportion of succesful trials") 
  
ggsave("figures/exp2_success_block_wide.pdf", width=6, height=4) 
```

Given the very high performance, it should be sufficient to report that mean in blocks 0 (white shapes) and 1 (trivial shapes) is high.

Block 0.
```{r}
mean(subset(pair_means_per_block,block_n==0)$score)
stem(subset(pair_means_per_block,block_n==0)$score)
```
Block 1.
```{r}
mean(subset(pair_means_per_block,block_n==1)$score)
stem(subset(pair_means_per_block,block_n==1)$score)
```


Key stat - are there effects of condition on score? We care about block 2 (Coloured Splats) onwards. We predict particularly an effect at block 2 (the Coloured Splats block), so want to get that straightforwardly from our analysis. We'd also like to know if the scores change over blocks, and whether this differ between conditions (extension to Coloured Shapes, Objects, Emotions). 

```{r}
matcher_data_block2on <- subset(matcher_data,block_n>=2)
matcher_data_block2on$block_n_factor <- as.factor(matcher_data_block2on$block_n)
matcher_data_block2on$condition_factor <- as.factor(matcher_data_block2on$condition)
matcher_data_block2on$block3_condition_factor <- as.factor(matcher_data_block2on$block3_condition)
contrasts(matcher_data_block2on$condition_factor) <- contr.sum(2)
contrasts(matcher_data_block2on$block3_condition_factor) <- contr.sum(3)
```

Take a look at the coding for the condition in the final extension block. So factor 1 is coloured shapes, factor 2 is emotions, and objects is sum of the negative effects of the other two categories (! see https://stackoverflow.com/questions/74288807/how-to-interpret-glmer-output-with-a-3-level-factor-encoded-as-contrast-sum).
```{r}
contrasts(matcher_data_block2on$block3_condition_factor)
```

Shows that the conditions (fixed vs random) differ at block 2, and they improve at block 3; no significant interactions, so basically the random_association guys start lower and (according to this) stay lower, regardless of whether the second extension is to Coloured Shapes, Emotions or Objects.
```{r}
score_model <- glmer(score~block_n_factor*condition_factor*block3_condition_factor + (1 + block_n_factor | pair_id),data=matcher_data_block2on,family='binomial',control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))

summary(score_model)
```

## Plots and stats of success over block and trial per block

Timecourses are useful, but to do these sensibly we need to convert trial_n (which is overall trial number) to something more meaningful, specifically trial number *in a given block*. Since there is some variability in trial number depending on what participants did on the warm-up trials, need to work out per-pair the lowest trial number per block and then subtract that from the raw trial numbers.

```{r}
adjusted_trial_n_df <- NULL
for (p in unique(matcher_data$pair_id)) {
  this_p_data <- subset(matcher_data,pair_id==p)
  for (b in unique(this_p_data$block_n)) {
    this_b_data <- subset(this_p_data,block_n==b)
    first_trial_n <- min(this_b_data$trial_n)
    this_df <- data.frame("pair_id"=p,
               "block_n"=b,
               "trial_n"=this_b_data$trial_n,
               "trial_n_in_block"=this_b_data$trial_n-first_trial_n)
    adjusted_trial_n_df <- rbind(adjusted_trial_n_df,this_df)
  }
}

#merge to get the adjusted trial numbers.
matcher_data <- merge(matcher_data,adjusted_trial_n_df,by=c("pair_id","block_n","trial_n"))
```

Plot the timecourses - note I am plotting the mean of all pairs here (since the individual pairs either succeed or fail on any given trial, so those are not informative) plus bootstrepped CIs, and focussing only on blocks 2 (splats) onwards. 

Plot block 2 first, before they diverge at block 3.

```{r, echo=FALSE}
matcher_data$trial_n_in_block_plus <- matcher_data$trial_n_in_block + 1


ggplot(data=subset(matcher_data,block_n==2)) +
  facet_grid(condition~block_n) +
  stat_summary(aes(x=trial_n_in_block_plus, y=score, group=1,colour=condition),geom="line", fun=mean) +
  stat_summary(aes(x=trial_n_in_block_plus, y=score,colour=condition),geom='errorbar', fun.data='mean_cl_boot',fun.min="min", fun.max="max",width=0.2) +
  theme(axis.text.x = element_text(angle = 90)) +
  #chance is 1 in 3
  geom_hline(yintercept=1/3, linetype="dashed") +
  theme_bw() +
  theme(legend.position = "none") +
  xlab("Trial number") +
  ylab("Proportion of succesful trials") +
  scale_colour_manual(values=my.colours) +
  scale_x_continuous(breaks=c(1,8,16,24,32))
``` 

The question with the stats here is: is there an interaction between condition and trial number? Doesn't come out in the stats, but I don't know if we need it to - you can see the much more rapid pick-up in the fixed condition.
```{r, cache=TRUE}
#need to re-run these since we have added the per-block trial numbers to matcher_data
matcher_data_block2on <- subset(matcher_data,block_n>=2)
matcher_data_block2on$condition_factor <- as.factor(matcher_data_block2on$condition)
contrasts(matcher_data_block2on$condition_factor) <- contr.sum(2)

#also need to scale and centre trial_n to ease convergence issues - setting so 0=-1, 31=1
matcher_data_block2on$trial_n_in_block_scaled_centred <- (matcher_data_block2on$trial_n_in_block-15.5)/15.5

score_model_trialn_block2 <- glmer(score~condition_factor*trial_n_in_block_scaled_centred + (1 + trial_n_in_block_scaled_centred | pair_id),data=subset(matcher_data_block2on,block_n==2),family='binomial',control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
summary(score_model_trialn_block2)
```


Then block 3, organised by block3_condition.

```{r}
ggplot(data=subset(matcher_data,block_n==3)) +
  facet_grid(condition~block3_condition) +
  stat_summary(aes(x=trial_n_in_block_plus, y=score, group=1,colour=condition),geom="line", fun=mean) +
  stat_summary(aes(x=trial_n_in_block_plus, y=score,colour=condition),geom='errorbar', fun.data='mean_cl_boot',fun.min="min", fun.max="max",width=0.2) +
  theme(axis.text.x = element_text(angle = 90)) +
  #chance is 1 in 3
  geom_hline(yintercept=1/3, linetype="dashed") +
  theme_bw() +
  theme(legend.position = "none") +
  xlab("Trial number") +
  ylab("Proportion of succesful trials") +
  scale_colour_manual(values=my.colours) +
  scale_x_continuous(breaks=c(1,8,16,24,32))
```

Looking at the plots, it looks like the curve is different between the Coloured Shapes and the other conditions? This is confirmed by the stats - with Coloured Shapes as reference level, there are interactions between trial_n and the other conditions (as well as effects reflecting the fact that we are not controlling for block 2 performance when just looking at block3 here).

Sum-code the block 3 condition.

```{r}
matcher_data_block2on$block3_condition <- factor(matcher_data_block2on$block3_condition)
contrasts(matcher_data_block2on$block3_condition)<-contr.sum(3)
contrasts(matcher_data_block2on$block3_condition)
```


```{r}
score_model_trialn_block3 <- glmer(score~condition_factor*block3_condition*trial_n_in_block_scaled_centred + (1 + trial_n_in_block_scaled_centred | pair_id),data=subset(matcher_data_block2on,block_n==3),family='binomial',control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
summary(score_model_trialn_block3)
```
Finally a plot in the same style as Experiment 1, showing performance on coloured splats and then the second extension block.

```{r}
matcher_data_for_timecourse_plot <- subset(matcher_data,block_n>=2)
matcher_data_for_timecourse_plot$compound_condition <- mapply(function(block,block3_condition) ifelse(block==2,"Coloured Splats",as.character(block3_condition)),
                                          matcher_data_for_timecourse_plot$block_n,
                                          matcher_data_for_timecourse_plot$block3_condition)
matcher_data_for_timecourse_plot$compound_condition <- plyr::revalue(factor(matcher_data_for_timecourse_plot$compound_condition),
                                              c("coloured_shapes"="Coloured Shapes",
                                                "objects"="Objects",
                                                "emotions"="Emotions"))
matcher_data_for_timecourse_plot$compound_condition <-factor(matcher_data_for_timecourse_plot$compound_condition,levels=c("Coloured Splats","Coloured Shapes","Objects","Emotions"))

matcher_data_for_timecourse_plot$named_condition <- plyr::revalue(matcher_data_for_timecourse_plot$condition,
                                              c("fixed_associations"="Fixed Associations",
                                                "random_associations"="Random Associations"))
```

```{r}
ggplot(data=matcher_data_for_timecourse_plot) +
  facet_grid(named_condition~compound_condition) +
  stat_summary(aes(x=trial_n_in_block_plus, y=score, group=1,colour=condition),geom="line", fun=mean) +
  stat_summary(aes(x=trial_n_in_block_plus, y=score,colour=condition),geom='errorbar', fun.data='mean_cl_boot',fun.min="min", fun.max="max",width=0.2) +
  theme(axis.text.x = element_text(angle = 90)) +
  #chance is 1 in 3
  geom_hline(yintercept=1/3, linetype="dashed") +
  theme_bw() +
  theme(legend.position = "none") +
  xlab("Trial number") +
  ylab("Proportion of succesful trials") +
  scale_colour_manual(values=my.colours) +
  scale_x_continuous(breaks=c(1,8,16,24,32))
  
ggsave("figures/exp2_success_by_trial.pdf", width=6, height=4)
```


## Are extensions made predicted?

*NB This is simpler than the matrix distance measure used in Bowerman & Smith (2022), and matches a KL-divergence measure which is a more elegant version of the Bowerman & Smith analysis (thanks to Matt Spike for suggesting KL-divergence).* 

We have a prediction for how people will extend their labels from block to block, and we can just score trials based on whether they match that prediction (1 = extended as predicted, 0 = not extended as predicted). For the fixed condition extending from Shapes to Coloured Splats this is particularly obvious - e.g. if Square is used all the time with Grey (Square) in the Shapes block, then Square should also be used to convey Grey (Splat) in the Coloured Splats block. For the random condition we can make the prediction based in frequency, and select randomly in the case of ties.

Data prep for doing the analysis.
```{r}
get_target_colour <- function(target_object) {
  strsplit(as.character(target_object),"_")[[1]][2]
}

get_target_shape <- function(target_object) {
  strsplit(as.character(target_object),"_")[[1]][1]
}

#shapes and colours are always separated by an underscore, so we can check for that
get_key_feature <- function(target_object) {
  if (grepl('_',as.character(target_object))) {
    get_target_colour(target_object)
  }
  else {as.character(target_object)}
}

director_data <- subset(data,exp_trial_type=='director' & block_n>0)
#need to extract colour, object or shape from the object column.
director_data$key_feature <- mapply(function(target) get_key_feature(target),
                                                   director_data$object)
#need to set up the levels of the key feature so that when we tabulate within a block we always get 
#the desired order of levels across blocks
director_data$key_feature <- factor(director_data$key_feature,levels=c("grey","pink","red","yellow",
                                                      "city","pig","volcano","banana",
                                                      "sad","inlove","angry","happy"))

#label is an integer 0-6 (local_label contains the mapping for each participant) - this means we can run the exact same analysis code as before, but we do need to convert this integer to a factor
director_data$label <- factor(director_data$label)

```


Code for tabulating meaning-label associations per block per pair.
```{r}
tabulate_pair <- function(all_data,id,print_output=FALSE) {
  this_pair_data <- subset(all_data,pair_id==id)
  this_pair_data$label <- droplevels(this_pair_data$label) #drop unused labels
  this_pair_max_association_table <- data.frame()
  if (print_output) {print(paste(id,unique(this_pair_data$condition)))}
  
  for (b in unique(all_data$block_n)) {
    this_block_associations <- subset(this_pair_data,block_n==b)
    this_block_associations$key_feature <- droplevels(this_block_associations$key_feature) #drop unused features
    this_block_associations_xtab <- xtabs(data=this_block_associations,~key_feature+label)
  if (print_output) {
    print(paste("block",b,"colour-shape associations"))
    print(this_block_associations_xtab)}
    #find max association per row in each block and add to this_pair_max_association_table
    for (r in 1:nrow(this_block_associations_xtab)) {
      this_row_label <- rownames(this_block_associations_xtab)[r]
      this_max_col <- nnet::which.is.max(this_block_associations_xtab[r,]) #breaks ties at random
      this_max_label <- colnames(this_block_associations_xtab)[this_max_col]
      this_pair_max_association_table <- rbind(this_pair_max_association_table,
                                    data.frame("pair_id"=id,
                                               "block_n"=b,
                                               "key_feature"=this_row_label,
                                                "max_label"=this_max_label))
    }
  }
  this_pair_max_association_table
}

```

Compile a dataframe of maximal associations at each block - we can use this to score each production as predicted or not.

```{r}
max_associations_df <- do.call(rbind, lapply(unique(director_data$pair_id), function(p) tabulate_pair(director_data,p)))
```

Now update the director_data dataframe, predicted column.  

```{r}
director_data$predicted <- mapply(function(pair,block,obj,l) {
  if (block==1) {predicted=NA} #no predictions for block 1
  else {
    key <- get_key_feature(obj) #key feature of object being labelled - need to convert this to relevant key feature at previous block
    if (key=="city" || key=="sad") {shifted_key = "grey"}
    else if (key=="pig" || key=="inlove") {shifted_key = "pink"}
    else if (key=="volcano" || key=="angry") {shifted_key = "red"}
    else if (key=="banana" || key=="happy") {shifted_key = "yellow"}
    else {shifted_key=key} #this will catch colour->colour
    predicted_label <- subset(max_associations_df,pair_id==pair & block_n==block-1 & key_feature==shifted_key)$max_label
    if (predicted_label==l) {predicted=1}
    else {predicted=0}
   
    predicted
}},
  director_data$pair_id,
director_data$block_n,
director_data$object,
director_data$label)
```

Save the resulting data frame to avoid recalculating for analysis comparing Experiments 1 and 2.
```{r}
write.csv(director_data,file="data/exp2_predicted_extension_data.csv",row.names=FALSE)
```

```{r}
pair_means_per_block_predicted <- aggregate(data=director_data,predicted~block_n+block3_condition+condition+pair_id,FUN=mean)
#need block_n as a factor for the dotplot
pair_means_per_block_predicted$block_n_as_factor <- factor(pair_means_per_block_predicted$block_n)

pair_means_per_block_predicted$named_condition <- plyr::revalue(pair_means_per_block_predicted$condition,
                                              c("fixed_associations"="Fixed Associations",
                                                "random_associations"="Random Associations"))

pair_means_per_block_predicted$named_block_n <- plyr::revalue(pair_means_per_block_predicted$block_n_as_factor,
                                              c("0"="White Shapes",
                                                "1"="Shapes",
                                                "2"="Coloured\nSplats",
                                                "3"="Second\nExtension"))

pair_means_per_block_predicted$named_block3_condition <- plyr::revalue(pair_means_per_block_predicted$block3_condition,
                                              c("coloured_shapes"="Coloured Shapes",
                                                "objects"="Objects",
                                                "emotions"="Emotions"))
```
                                                
```{r, echo=FALSE}
ggplot(data=subset(pair_means_per_block_predicted,block_n>=2),aes(x=named_block_n, y=predicted)) +
  facet_grid(named_block3_condition~named_condition) +
  stat_summary(geom='point', fun='mean', colour='black',fill='black',size=2, shape=23) +
  stat_summary(geom='errorbar', fun.data='mean_cl_boot',fun.min="min", fun.max="max",width=0.2) +
  geom_dotplot(aes(x=named_block_n, y=predicted,fill=condition),binaxis='y',stackdir="center", binwidth = .025, binpositions='all', dotsize=0.5, alpha=0.5) +
  scale_fill_manual(values=my.colours) +
  theme_bw() +
  theme(legend.position = "none") +
  theme(axis.title.x = element_blank()) +
  ylab("Proportion of extensions as predicted")
```

Plotting in the style consistent with experiment 1.

```{r, echo=FALSE}

pair_means_per_block_predicted_replot <- pair_means_per_block_predicted
pair_means_per_block_predicted_replot$temp <- paste(pair_means_per_block_predicted_replot$block_n,pair_means_per_block_predicted_replot$named_block3_condition)
pair_means_per_block_predicted_replot$temp2 <- plyr::revalue(factor(pair_means_per_block_predicted_replot$temp),
                                              c("0 Objects"="White Shapes",
                                                "1 Objects"="Shapes",
                                                "2 Objects" = "Coloured\nSplats",
                                                "3 Objects" = "Objects",
                                                "0 Emotions"="White Shapes",
                                                "1 Emotions"="Shapes",
                                                "2 Emotions" = "Coloured\nSplats",
                                                "3 Emotions" = "Emotions",
                                                "0 Coloured Shapes"="White Shapes",
                                                "1 Coloured Shapes"="Shapes",
                                                "2 Coloured Shapes" = "Coloured\nSplats",
                                                "3 Coloured Shapes" = "Coloured\nShapes"))
                                                
                                                
pair_means_per_block_predicted_replot$temp2 <- factor(pair_means_per_block_predicted_replot$temp2,levels=c("White Shapes","Shapes","Coloured\nSplats","Coloured\nShapes","Objects","Emotions"))

pair_means_per_block_predicted_replot$temp2 <- plyr::revalue(pair_means_per_block_predicted_replot$temp2,
                                              c("Coloured\nSplats"="Shapes to\nColoured Splats",
                                                "Coloured\nShapes"="Coloured Splats to\nColoured Shapes",
                                                "Objects"="Coloured Splats to\nObjects",
                                                "Emotions"="Coloured Splats to\nEmotions"))
```


```{r, echo=FALSE}
ggplot(data=subset(pair_means_per_block_predicted_replot,block_n>=2),aes(x=temp2, y=predicted)) +
  facet_grid(~named_condition) +
  stat_summary(geom='point', fun='mean', colour='black',fill='black',size=2, shape=23) +
  stat_summary(geom='errorbar', fun.data='mean_cl_boot',fun.min="min", fun.max="max",width=0.2) +
  geom_dotplot(aes(x=temp2, y=predicted,fill=condition),binaxis='y',stackdir="center", binwidth = .025, binpositions='all', dotsize=0.5, alpha=0.5) +
  scale_fill_manual(values=my.colours) +
  theme_bw() +
  theme(legend.position = "none") +
  theme(axis.title.x = element_blank()) +
   theme(axis.text.x = element_text(angle=30, hjust=1)) +
  ylab("Proportion of extensions as predicted")

ggsave("figures/exp2_block_to_block_extend_as_predicted.pdf", width=6, height=4)
```

Stats - first, dummy-coded model to show a clear difference between fixed and random conditions at extension to block 2. 

```{r}
director_data_block2on <- subset(director_data,block_n>=2)
director_data_block2on$block_n_factor <- as.factor(director_data_block2on$block_n)
director_data_block2on$condition_factor <- as.factor(director_data_block2on$condition)
director_data_block2on$block3_condition_factor <- as.factor(director_data_block2on$block3_condition)
contrasts(director_data_block2on$condition_factor) <- contr.sum(2)
contrasts(director_data_block2on$block3_condition_factor) <- NULL

predicted_model_dummy <-  glmer(predicted~block_n_factor*condition_factor*block3_condition_factor + (1 + block_n_factor| pair_id),data=director_data_block2on,family='binomial',control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))

summary(predicted_model_dummy)
```

Then, simple model to show what happens at the block 2-3 extension. This shows that the extension is less straightforward in the more abstract Objects and Emotions conditions, and that once the Coloured Splats block has been used to establish conventions, there is no difference based on the fixed vs random conditions (the extension prediction scores are higher in the fixed conditions, but not significantly so). 

```{r}
director_data_block2on$block3_condition_sdif <- factor(director_data_block2on$block3_condition,levels=c("coloured_shapes","objects","emotions"))
contrasts(director_data_block2on$block3_condition_sdif) <- MASS::contr.sdif(3)
second_extension_model <- glmer(predicted~condition_factor*block3_condition_sdif + (1 | pair_id),data=subset(director_data_block2on,block_n==3),family='binomial',control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
summary(second_extension_model)
```

It would be nice also to know if Objects and Emotions differ, so I am doing a successive differences coding. The result is now a main effect of condition (so averaging over block3 conditions, the fixed guys *do* have lower association scores), and also the successive differences are significant, so Objects has lower predicted scores than Coloured Shapes, and Emotions is lower than Objects.

```{r}
second_extension_data <- subset(director_data_block2on,block_n==3)
second_extension_data$block3_condition_sdif <- factor(second_extension_data$block3_condition,levels=c("coloured_shapes","objects", "emotions"))
                                                                       
contrasts(second_extension_data$block3_condition_sdif) <- MASS::contr.sdif(3)

second_extension_model_sdif <- glmer(predicted~condition_factor*block3_condition_sdif + (1 | pair_id),data=second_extension_data,family='binomial',control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
summary(second_extension_model_sdif)

```

## Block-to-block distances in association matrices using KL-divergence 

Including this for completeness.

Code for this matrix distance z-scoring.
```{r}
#prior in the dirichlet prior for the KL-divergence calculation
kl_dirichlet_prior = 1

#a will be block n, b will be block n+1, these are reversed in the entropy::KL.Dirichlet call
distribution_distance_z <- function(a,b) {
    veridical_kl_divergence <- entropy::KL.Dirichlet(b,a,a1=kl_dirichlet_prior,a2=kl_dirichlet_prior)
    msample <- c()
    perms <- gtools::permutations(4,4)
    for (perm_i in 2:nrow(perms)) {#skip original 'permutation', which is not a permutation
      this_perm <- perms[perm_i,]
      this_divergence <- entropy::KL.Dirichlet(b[,this_perm],a,a1=kl_dirichlet_prior,a2=kl_dirichlet_prior)
      msample <- c(msample,this_divergence)
    }
    c=0
    for (i in 1:length(msample)) {
      if(msample[i]>=veridical_kl_divergence) c=c+1
    }
    
    return(list(mean=mean(msample),sd=sd(msample),veridical=veridical_kl_divergence,p=c/length(msample),z=(veridical_kl_divergence-mean(msample))/sd(msample)))
}
```


Code for tabulating and calculating distances per pair.
```{r}
tabulate_pair_kl <- function(all_data,id,print_output=FALSE) {
  this_pair_data <- subset(all_data,pair_id==id)
  this_pair_data$label <- droplevels(this_pair_data$label) #drop unused labels
  this_pair_matrices <- list()
  if (print_output) {print(paste(id,unique(this_pair_data$condition)))}
  
  for (b in unique(all_data$block_n)) {
    this_block_associations <- subset(this_pair_data,block_n==b)
    this_block_associations$key_feature <- droplevels(this_block_associations$key_feature) #drop unused features
    this_block_associations_xtab <- xtabs(data=this_block_associations,~key_feature+label)
  if (print_output) {
    print(paste("block",b,"colour-shape associations"))
    print(this_block_associations_xtab)}
  this_block_associations_matrix <- matrix(this_block_associations_xtab,
                                            dim(this_block_associations_xtab))
  this_pair_matrices[[b]] <- this_block_associations_matrix
  }
  #now we have all the block matrices we can compare
  block_1_2_dist <- distribution_distance_z(this_pair_matrices[[1]],this_pair_matrices[[2]])$z
  block_2_3_dist <- distribution_distance_z(this_pair_matrices[[2]],this_pair_matrices[[3]])$z
  
  this_dist_data <- data.frame("pair_id"=id,
                                 "condition"=unique(this_pair_data$condition),
                               "block3_condition"=unique(this_pair_data$block3_condition),
                                 "blocks"=c("1-2","2-3"),
                                 "distance"=c(block_1_2_dist,block_2_3_dist)
  )
  this_dist_data
  
}

```

Finally, calculate the distances and compile into a dataframe called block_to_block_distances.
```{r}
block_to_block_distances <- do.call(rbind, lapply(unique(director_data$pair_id), function(p) tabulate_pair_kl(director_data,p)))
```


Plot facetted by condition - key thing here is that the block3_conditions look similar at the initial extension block (i.e. before they diverge).

```{r, echo=FALSE}
ggplot(data=block_to_block_distances,aes(x=blocks, y=distance)) +
  facet_grid(block3_condition~condition) +
  stat_summary(geom='point', fun='mean', colour='black',fill='black',size=2, shape=23) +
  stat_summary(geom='errorbar', fun.data='mean_cl_boot',fun.min="min", fun.max="max",width=0.2) +
  geom_dotplot(aes(x=blocks, y=distance,fill=condition),binaxis='y',stackdir="center", binwidth = .025, binpositions='all', alpha=0.5) +
  scale_fill_manual(values=my.colours) +
  theme_bw() +
  theme(legend.position = "none") +
  theme(axis.title.x = element_blank()) +
  ylab("Proportion of succesful trials") 
```

And plot again with the initial extension block collapsed across block3 conditions.

```{r, echo=FALSE}

block_to_block_distances$temp <- paste(block_to_block_distances$blocks,block_to_block_distances$block3_condition)
block_to_block_distances$temp2 <- plyr::revalue(factor(block_to_block_distances$temp),
                                              c("1-2 objects"="Shapes to Coloured Splats",
                                                "2-3 objects"="Coloured Splats to Objects",
                                                "1-2 emotions"="Shapes to Coloured Splats",
                                                "2-3 emotions"="Coloured Splats to Emotions",
                                                "1-2 coloured_shapes"="Shapes to Coloured Splats",
                                                "2-3 coloured_shapes"="Coloured Splats to Coloured Shapes"))
               
                                 
block_to_block_distances$temp2 <- factor(block_to_block_distances$temp2,levels = c("Shapes to Coloured Splats",
                                                                                   "Coloured Splats to Coloured Shapes",
                                                                                   "Coloured Splats to Objects",
                                                                                   "Coloured Splats to Emotions"))
```

```{r, echo=FALSE}
block_to_block_distances$named_condition <- plyr::revalue(block_to_block_distances$condition,
                                              c("fixed_associations"="Fixed Associations",
                                                "random_associations"="Random Associations"))

ggplot(data=block_to_block_distances) +
  facet_grid(~named_condition) +
  stat_summary(aes(x=temp2, y=distance),geom='point', fun='mean', colour='black',fill='black',size=2, shape=23) +
  stat_summary(aes(x=temp2, y=distance),geom='errorbar', fun.data='mean_cl_boot',fun.min="min", fun.max="max",width=0.2) +
  geom_dotplot(aes(x=temp2, y=distance, fill=condition),binaxis='y',stackdir="center",
               binpositions='all', dotsize=0.6,alpha=0.5) +
  theme_bw() +
  scale_fill_manual(values=my.colours) +
  theme(legend.position = "none") +
  theme(axis.title.x = element_blank()) +
  ylab("Block-to-block difference (z-score)") +
  theme(axis.text.x = element_text(angle=30, hjust=1))

ggsave("figures/exp2_block_to_block_difference.pdf", width=6, height=4)
```

Stats - first, dummy-coded model to show a clear difference between fixed and random conditions at extension to block 2. 

```{r}
block_to_block_distances_model_dummy <-  lmerTest::lmer(distance~blocks*condition*block3_condition + (1 | pair_id),data=block_to_block_distances,control=lmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
summary(block_to_block_distances_model_dummy)
```

Then, simple model to show what happens at the block 2-3 extension - since we only have one observation per pair here we can just use a normal linear model. This shows that the extension is less straightforward in the more abstract Objects and Emotions conditions (extension z-scores are significantly higher), and that once the Coloured Splats block has been used to establish conventions, there is no difference based on the fixed vs random conditions (the extension scores are higher in the random conditions, but not significantly so). 

```{r}
block_to_block_distances_2nd_extension <- subset(block_to_block_distances,blocks=="2-3")
block_to_block_distances_2nd_extension$condition <- factor(block_to_block_distances_2nd_extension$condition)
contrasts(block_to_block_distances_2nd_extension$condition) <- contr.sum(2)

block_to_block_distances_2nd_extension_model <-  lm(distance~condition*block3_condition,data=block_to_block_distances_2nd_extension)
summary(block_to_block_distances_2nd_extension_model)
```

It would be nice also to know if Objects and Emotions differ, so I am doing a successive differences coding. The result is now a main effect of condition (so averaging over block3 conditions, the fixed guys *do* have lower association scores), and also the successive differences are significant, so Objects has higher extension z-scores than Coloured Shapes, and Emotions is higher than Objects.

```{r}
block_to_block_distances_2nd_extension$block3_condition_sdif <- factor(block_to_block_distances_2nd_extension$block3_condition,levels=c("coloured_shapes","objects", "emotions"))
                                                                       
contrasts(block_to_block_distances_2nd_extension$block3_condition_sdif) <- MASS::contr.sdif(3)

block_to_block_distances_2nd_extension_sdif_model <- lm(distance~condition*block3_condition_sdif,data=block_to_block_distances_2nd_extension)
summary(block_to_block_distances_2nd_extension_sdif_model)

```

## Non-arbitrariness of colour-shape correspondences in the arbitrary condition

The additional steps we took in this experiment, where different participants get different shape mappings, reduces but does not eliminate the non-random associations - red no longer maps so closely to cross, and the table is generally less skewed (the chi-squared value is approximately the same as in experiment 1, but the entries are all larger, and chi-squared should increase as a function of sample size all other things being equal). Red no longer has a strong preference for cross, but the strongest association from experiment 1 (yellow->star) is still in there.

```{r}
random_block2_associations_data <- subset(director_data,block_n==2 & condition=='random_associations')
random_block2_associations_xtab <- xtabs(data=random_block2_associations_data,~key_feature+local_label,drop.unused.levels=TRUE)
random_block2_associations_xtab
chisq.test(random_block2_associations_xtab)
```

To show that this is less skewed than the experiment 1 table, we can convert into the same scale (by converting to proportion then multiplying by the number of observations in the equivalent table in experiment 1, 1696). chi-squared value here is 62.3, as opposed to 208.4 in Experiment 1.

```{r}
chisq.test(random_block2_associations_xtab/sum(random_block2_associations_xtab)*1696)
```

Worth doing this in block 3 as well - are there any striking associations between e.g. shape and object, shape and emotion? Pig->circle, happy->star are the only obvious ones that stand out.

```{r}
random_block3_associations_data <- subset(director_data,block_n==3 & condition=='random_associations')
random_block3_associations_xtab <- xtabs(data=random_block3_associations_data,~key_feature+local_label,drop.unused.levels=TRUE)
random_block3_associations_xtab
chisq.test(random_block3_associations_xtab)
```



